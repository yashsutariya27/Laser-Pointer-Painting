import { parseRange } from 'header-range-parser';
import { fresh } from 'es-fresh';
import { typeIs } from '@tinyhttp/type-is';
import { Accepts } from '@tinyhttp/accepts';
export * from '@tinyhttp/url';

const getAccepts = (req) => (...types) => new Accepts(req).types(types);
const getAcceptsEncodings = (req) => (...encodings) => new Accepts(req).encodings(encodings);
const getAcceptsCharsets = (req) => (...charsets) => new Accepts(req).charsets(charsets);
const getAcceptsLanguages = (req) => (...languages) => new Accepts(req).languages(languages);

const getRequestHeader = (req) => (header) => {
    const lc = header.toLowerCase();
    switch (lc) {
        case 'referer':
        case 'referrer':
            return req.headers.referrer || req.headers.referer;
        default:
            return req.headers[lc];
    }
};
const getRangeFromHeader = (req) => (size, options) => {
    const range = getRequestHeader(req)('Range');
    if (!range)
        return;
    return parseRange(size, range, options);
};
const getFreshOrStale = (req, res) => {
    const method = req.method;
    const status = res.statusCode;
    // GET or HEAD for weak freshness validation only
    if (method !== 'GET' && method !== 'HEAD')
        return false;
    // 2xx or 304 as per rfc2616 14.26
    if ((status >= 200 && status < 300) || status === 304) {
        return fresh(req.headers, {
            etag: res.getHeader('ETag'),
            'last-modified': res.getHeader('Last-Modified')
        });
    }
    return false;
};
const checkIfXMLHttpRequest = (req) => req.headers['X-Requested-With'] === 'XMLHttpRequest';
const reqIs = (req) => (...types) => typeIs(req.headers['content-type'], ...types);

export { checkIfXMLHttpRequest, getAccepts, getAcceptsCharsets, getAcceptsEncodings, getAcceptsLanguages, getFreshOrStale, getRangeFromHeader, getRequestHeader, reqIs };
